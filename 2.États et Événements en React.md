# États et Événements en React

# États -- useState()

# Gestion des Événements dans React

La gestion des événements dans React est un aspect essentiel pour rendre une application interactive. React utilise une approche particulière pour gérer les événements, ce qui diffère légèrement de la gestion classique des événements DOM en JavaScript. Voici une explication avec l'exemple fourni.

---

## **1. Initialisation de l'État dans React**

Dans React, lorsqu'une variable est définie normalement (`let message = ""`), elle ne peut pas être mise à jour dynamiquement dans l'interface utilisateur. React ne suit pas les modifications apportées à des variables simples. Au lieu de cela, React utilise un **état** pour détecter et refléter les changements dans l'interface utilisateur.

### Exemple d'état avec `useState`

Dans l'exemple ci-dessus, l'état est utilisé pour stocker le message :

```jsx
const [message, definirMessage] = useState("");
```

- `message` : contient la valeur actuelle de l'état.
- `definirMessage` : une fonction qui met à jour la valeur de `message`.
- `useState("")` : initialise l'état avec une valeur vide (`""`).

---

## **2. Gestionnaire d'Événement**

Un gestionnaire d'événement est une fonction exécutée lorsqu'un événement (comme un clic ou une saisie) est déclenché.

Dans cet exemple, la fonction `gestionnaireClique` est déclenchée lors du clic sur le bouton :

```jsx
const gestionnaireClique = () => {
  definirMessage("Cliquez sur le bouton !");
  console.log("bouton clique");
};
```

- `definirMessage("Cliquez sur le bouton !")` : met à jour l'état avec un nouveau message.
- `console.log("bouton clique")` : affiche un message dans la console.

---

## **3. Attachement de l'Événement**

Dans React, les événements sont attachés directement aux éléments HTML avec des attributs similaires à ceux du DOM, mais en camelCase. Par exemple :

```jsx
<button onClick={gestionnaireClique}>Cliquez ici</button>
```

- `onClick` : nom de l'événement (équivalent de `onclick` en HTML).
- `gestionnaireClique` : fonction appelée lorsque l'événement est déclenché.

---

## **4. Cycle de Mise à Jour**

Lorsqu'un événement est déclenché (par exemple, le clic sur le bouton) :

1. React appelle la fonction de gestionnaire d'événement.
2. Si l'état est mis à jour via `useState`, React détecte le changement.
3. React re-render l'interface utilisateur pour refléter la nouvelle valeur de l'état.

Dans l'exemple :

- Initialement, `message` est vide.
- Lorsque le bouton est cliqué, `definirMessage` met à jour l'état avec `"Cliquez sur le bouton !"`.
- React met à jour le contenu de `<h1>` pour afficher ce message.

---

## **5. Pourquoi l'État est Nécessaire ?**

Si vous utilisez une variable simple comme `let message`, React ne détectera pas les changements, car il ne surveille pas les variables ordinaires. En revanche, l'utilisation de l'état permet à React de réagir aux changements et de mettre à jour automatiquement l'interface utilisateur.

---

### **Résumé :**

- Utilisez `useState` pour gérer l'état dans React.
- Les événements comme `onClick` permettent de réagir aux interactions utilisateur.
- React met à jour automatiquement l'interface utilisateur lorsque l'état change.

```jsx
import { useState } from "react";

function App() {
  // let message = ""; // ici nous allons stocker le message
  const [message, definirMessage] = useState("");

  const gestionnaireClique = () => {
    // message = "Cliquez sur le bouton !"; il ne fonctionne pas
    definirMessage("Cliquez sur le bouton !");
    console.log("bouton clique");
  };

  return (
    <>
      <h1>{message}</h1>
      <button onClick={gestionnaireClique}>Cliquez ici</button>
    </>
  );
}

export default App;
```

# Formulaire et Événements dans React : Table de Référence

Voici une table récapitulant les principaux concepts et méthodes liés aux formulaires et aux événements dans React :

| **Concept/Élément**                 | **Description**                                                                                  | **Exemple**                                                                                                                                                                           |
| ----------------------------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Formulaire contrôlé**             | Un formulaire dont les valeurs des champs sont gérées par l'état React via `useState`.           | `jsx<br />const [valeur, setValeur] = useState("");<br /><input type="text" value={valeur} onChange={(e) => setValeur(e.target.value)} /><br />`                                      |
| **Formulaire non contrôlé**         | Un formulaire géré directement par le DOM, généralement en accédant à ses valeurs via une `ref`. | `jsx<br />const ref = useRef();<br /><input type="text" ref={ref} /><br />console.log(ref.current.value);<br />`                                                                      |
| **Événement `onChange`**            | Déclenché chaque fois que la valeur d'un champ d'entrée change.                                  | `jsx<br /><input type="text" onChange={(e) => console.log(e.target.value)} /><br />`                                                                                                  |
| **Événement `onSubmit`**            | Utilisé pour capturer l'envoi d'un formulaire.                                                   | `jsx<br /><form onSubmit={(e) => { e.preventDefault(); console.log("Form soumis"); }}><br /><button type="submit">Envoyer</button><br /></form><br />`                                |
| **Utilisation de plusieurs champs** | Gérer plusieurs champs avec un seul état en utilisant un objet.                                  | `jsx<br />const [formData, setFormData] = useState({ nom: "", email: "" });<br /><input name="nom" onChange={(e) => setFormData({...formData, nom: e.target.value})}/><br />`         |
| **Validation**                      | Vérifier les valeurs des champs et afficher des erreurs ou des messages d'aide.                  | `jsx<br />if (!valeur) { setErreur("Champ obligatoire"); }<br />`                                                                                                                     |
| **Initialisation des valeurs**      | Fixer des valeurs initiales pour les champs du formulaire.                                       | `jsx<br />const [valeur, setValeur] = useState("Défaut");<br />`                                                                                                                      |
| **Checkbox et `onChange`**          | Gérer les cases à cocher avec un état booléen.                                                   | `jsx<br />const [checked, setChecked] = useState(false);<br /><input type="checkbox" checked={checked} onChange={(e) => setChecked(e.target.checked)} /><br />`                       |
| **Select et options**               | Gérer les menus déroulants (`select`) en associant une valeur au champ via l'état.               | `jsx<br />const [option, setOption] = useState("");<br /><select value={option} onChange={(e) => setOption(e.target.value)}><br /><option value="1">Option 1</option></select><br />` |
| **Bouton `reset`**                  | Réinitialiser les champs du formulaire à leurs valeurs initiales.                                | `jsx<br /><button onClick={() => setFormData({ nom: "", email: "" })}>Réinitialiser</button><br />`                                                                                   |

---

### Le Two-Way Binding en React

Le **two-way binding** est un concept qui permet de synchroniser l'état entre un composant React et les éléments de l'interface utilisateur (comme les champs de formulaire). Autrement dit, lorsque l'état de l'application change, la vue est mise à jour, et vice versa, lorsque l'utilisateur modifie l'interface (par exemple en tapant dans un champ de texte), l'état de l'application est automatiquement mis à jour.

En React, le **two-way binding** est couramment réalisé en utilisant les propriétés `value` et `onChange` des éléments de formulaire (comme les champs de texte, les cases à cocher, etc.).

#### Comment ça fonctionne ?

1. **`value`** : L'attribut `value` permet de lier un champ de formulaire (par exemple, un `<input>`) à l'état d'un composant React. La valeur de cet élément devient contrôlée par l'état du composant.

2. **`onChange`** : L'attribut `onChange` est utilisé pour écouter les modifications de l'élément. Lorsque l'utilisateur modifie le champ de formulaire, une fonction est appelée, qui met à jour l'état en fonction de la nouvelle valeur.

Cela crée une liaison bidirectionnelle entre l'élément de l'interface et l'état du composant.

#### Exemple de Two-Way Binding :

Voici un exemple simple où un champ de texte est lié à l'état `nom`. Lorsque l'utilisateur tape dans le champ de texte, l'état est mis à jour, et l'interface réagit immédiatement pour refléter cette mise à jour.

```javascript
import { useState } from "react";

function App() {
  // Initialisation de l'état
  const [nom, definirNom] = useState("");

  // Fonction pour gérer les changements de valeur
  const gestionnaireDeEventdeNom = (event) => {
    definirNom(event.target.value);
  };

  return (
    <div>
      <input
        type='text'
        value={nom} // Liaison de la valeur du champ avec l'état
        onChange={gestionnaireDeEventdeNom} // Mise à jour de l'état lorsque l'utilisateur tape
        placeholder='Entrez votre nom'
      />
      <p>Nom: {nom}</p> {/* Affichage du nom en temps réel */}
    </div>
  );
}

export default App;
```

### Explication du code :

- **`value={nom}`** : Le champ de texte affiche la valeur de l'état `nom`. Dès que l'état change, la valeur du champ se met à jour automatiquement.
- **`onChange={gestionnaireDeEventdeNom}`** : Cette fonction est appelée chaque fois que l'utilisateur tape dans le champ de texte. Elle met à jour l'état `nom` avec la nouvelle valeur du champ (`event.target.value`).

Cela permet d'obtenir un **two-way binding**, où l'état et l'interface utilisateur restent toujours synchronisés.

### Avantages du Two-Way Binding :

- **Réactivité** : L'interface utilisateur est automatiquement mise à jour lorsque l'état change, ce qui assure une expérience utilisateur fluide.
- **Simplicité** : Cela permet de garder le code simple et de ne pas avoir à manipuler manuellement le DOM.
- **Synchronisation** : Toute modification de l'interface se répercute immédiatement dans l'état du composant et vice versa.

### Différence avec le One-Way Data Binding :

- En **one-way data binding** (liaison unidirectionnelle), l'état du composant est responsable de l'affichage dans l'interface, mais l'interface ne met pas à jour l'état automatiquement. Si vous voulez que l'état change en fonction des interactions de l'utilisateur, vous devez le faire explicitement avec des événements (comme `onClick`, `onChange`, etc.).
- Le **two-way binding** permet de faire les deux : l'état et la vue sont synchronisés automatiquement dans les deux directions.

### Conclusion :

Le **two-way binding** est une approche puissante pour gérer les interactions entre l'état d'un composant React et l'interface utilisateur, surtout dans des formulaires ou des interfaces nécessitant une saisie active de l'utilisateur. Cependant, il est important de noter que React utilise principalement **une liaison unidirectionnelle** (unidirectional data flow) pour gérer les données à travers l'application, et le two-way binding est une extension de ce principe dans les cas spécifiques de formulaires contrôlés.

```jsx
import { useState } from "react";

function App() {
  const [entree, definirEntree] = useState("");

  const gestionnareDeEntree = (e) => {
    definirEntree(e.target.value);
  };

  return (
    <>
      <h2>Valeur:{entree}</h2>
      <input type='text' value={entree} onChange={gestionnareDeEntree} />
    </>
  );
}

export default App;
```

```jsx
import { useState } from "react";

function App() {
  return (
    <>
      <h1>{voitureSelecte}</h1>
      <select id='voiture' onChange={gestionnaireSelection}>
        {voitures.map((voiture, cle) => {
          return (
            <option key={cle} value={voiture}>
              {voiture}
            </option>
          );
        })}
      </select>
    </>
  );
}

export default App;
```

## Gestion de l'État sous forme d'Objet dans React

Dans cet exemple, l'état d'une application React est représenté sous la forme d'un **objet** pour regrouper plusieurs propriétés liées entre elles, telles que `nom`, `prenom`, et `date`. Cela simplifie la gestion des données et permet une mise à jour cohérente.

---

### Pourquoi Utiliser un Objet pour l'État ?

1. **Regroupement de Données Connexes** :

   - Lorsque plusieurs variables d'état (comme `nom`, `prenom`, et `date`) sont étroitement liées, les regrouper dans un seul objet améliore la lisibilité et la gestion du code.

2. **Réduction du Nombre de Variables d'État** :

   - Plutôt que de définir un état distinct pour chaque champ :
     ```jsx
     const [nom, definirNom] = useState("");
     const [prenom, definirPrenom] = useState("");
     const [date, definirDate] = useState("");
     ```
     Vous pouvez tout regrouper dans un seul objet :
     ```jsx
     const [entreeUtilisateur, definirEntreeUtilisateur] = useState({
       nom: "",
       prenom: "",
       date: "",
     });
     ```

3. **Mises à Jour Simples** :
   - Une seule fonction de mise à jour peut modifier les propriétés individuelles de l'objet sans affecter les autres, grâce à la syntaxe **spread operator** (`...`).

---

### Exemple en Action

#### Structure HTML

Le tableau affiche les valeurs des champs d'entrée en temps réel :

```jsx
<table>
  <tr>
    <th>Nom</th>
    <th>Prénom</th>
    <th>Date</th>
  </tr>
  <tr>
    <td>{entreeUtilisateur.nom}</td>
    <td>{entreeUtilisateur.prenom}</td>
    <td>{entreeUtilisateur.date}</td>
  </tr>
</table>
```

#### Composant React

Chaque champ d'entrée met à jour une propriété spécifique de l'état tout en conservant les autres valeurs inchangées. Voici l'extrait principal :

```jsx
<input
  type='text'
  value={entreeUtilisateur.nom}
  onChange={(e) =>
    definirEntreeUtilisateur({
      ...entreeUtilisateur, // Conserve les autres propriétés existantes
      nom: e.target.value, // Met à jour uniquement `nom`
    })
  }
/>
```

---

### Limites et Recommandations

#### **Avantages :**

- **Lisibilité** : Les données liées sont centralisées, ce qui rend le code plus propre.
- **Simplicité** : Une seule fonction de mise à jour pour gérer l'état global.

#### **Inconvénients :**

- **Complexité de la Mise à Jour** : Si l'objet contient de nombreuses propriétés imbriquées, gérer l'état peut devenir difficile sans librairies comme `Immer` ou un gestionnaire d'état global (ex. Redux).
- **Problèmes de Performance** : Lorsque l'objet est mis à jour, le composant React entier est re-rendu, même si une seule propriété a changé.

#### **Recommandé Quand :**

- Les propriétés d'état sont logiquement connectées.
- Le nombre de propriétés est gérable (pas trop profondes ou imbriquées).

#### **À Éviter Quand :**

- Vous avez des propriétés complètement indépendantes.
- Vous gérez des objets très complexes. Dans ce cas, envisagez d'utiliser un outil de gestion d'état externe.

---

# Comprendre et Utiliser l'État Précédent dans React

Lorsqu'on gère des objets complexes ou des états dépendants d'une modification dans React, l'utilisation de l'état précédent devient essentielle. Voici une explication claire et détaillée de la manière dont cela fonctionne.

---

## Pourquoi Utiliser l'État Précédent ?

Lorsque vous mettez à jour un état basé sur sa valeur actuelle, il est préférable d'utiliser une **fonction de mise à jour** avec l'état précédent. Cela garantit que les modifications sont appliquées correctement, surtout dans des cas où plusieurs mises à jour peuvent se produire simultanément (comme lors de plusieurs interactions utilisateur ou en raison d'asynchronisme).

---

## Exemple de Fonctionnement

Dans l'exemple suivant, nous utilisons `useState` pour gérer un objet représentant les données d'un utilisateur. Nous avons plusieurs champs d'entrée : _nom_, _prénom_, et _date_. L'état est un objet regroupant ces valeurs.

### Code avec l'État Précédent

```jsx
import { useState } from "react";

function App() {
  // Initialisation de l'état
  const [entreeUtilisateur, definirEntreeUtilisateur] = useState({
    nom: "",
    prenom: "",
    date: "",
  });

  return (
    <>
      <div>
        <table>
          <tr>
            <th>Nom</th>
            <th>Prénom</th>
            <th>Date</th>
          </tr>
          <tr>
            <td>{entreeUtilisateur.nom}</td>
            <td>{entreeUtilisateur.prenom}</td>
            <td>{entreeUtilisateur.date}</td>
          </tr>
        </table>
      </div>

      {/* Mise à jour du champ nom */}
      <input
        type='text'
        value={entreeUtilisateur.nom}
        onChange={(e) =>
          definirEntreeUtilisateur((precedent) => ({
            ...precedent,
            nom: e.target.value,
          }))
        }
      />

      {/* Mise à jour du champ prénom */}
      <input
        type='text'
        value={entreeUtilisateur.prenom}
        onChange={(e) =>
          definirEntreeUtilisateur((precedent) => ({
            ...precedent,
            prenom: e.target.value,
          }))
        }
      />

      {/* Mise à jour du champ date */}
      <input
        type='date'
        value={entreeUtilisateur.date}
        onChange={(e) =>
          definirEntreeUtilisateur((precedent) => ({
            ...precedent,
            date: e.target.value,
          }))
        }
      />
    </>
  );
}

export default App;
```

---

## Analyse de la Mise à Jour avec l'État Précédent

### Étapes Clés :

1. **Accès à l'État Précédent** :

   - La fonction passée à `definirEntreeUtilisateur` reçoit l'état précédent comme argument.
   - Cet état précédent est utilisé pour copier toutes les autres propriétés qui ne sont pas modifiées.

2. **Mise à Jour Partielle** :
   - Grâce à l'opérateur de décomposition (`...precedent`), nous copions les valeurs actuelles de l'état tout en modifiant uniquement la propriété ciblée (comme `nom`, `prenom`, ou `date`).

### Avantages :

- **Précision** : Seule la propriété spécifiée est mise à jour sans affecter les autres champs.
- **Fiabilité** : Empêche les problèmes liés aux mises à jour asynchrones dans React.
- **Lisibilité** : Le code est plus clair et facile à maintenir.

---

## Résultat dans le Navigateur

Lorsqu'un utilisateur remplit un champ d'entrée :

- La valeur est mise à jour dynamiquement dans l'état grâce à `setState`.
- Les données sont affichées dans le tableau sans affecter les autres champs.

---

## Quand Utiliser cette Approche ?

- Lorsque vous gérez un état **complexe ou imbriqué**.
- Si les **mises à jour simultanées ou asynchrones** de l'état peuvent provoquer des incohérences.
- Pour **éviter d'écraser accidentellement** les autres parties de l'état lors de la mise à jour d'une seule propriété.

---

## Points à Garder à l'Esprit

- Si vous travaillez avec des états très imbriqués, envisagez d'utiliser une gestion d'état plus avancée comme `useReducer`.
- Assurez-vous de toujours copier l'état précédent pour préserver les propriétés non modifiées.

---

```jsx
import { useState } from "react";

function App() {
  const [nom, definirNom] = useState("");
  const [prenom, definirPrenom] = useState("");
  const [date, definirDate] = useState("");

  return (
    <>
      <div>
        <table>
          <tr>
            <th>Nom</th>
            <th>Prénom</th>
            <th>Date</th>
          </tr>
          <tr>
            <td>{nom}</td>
            <td>{prenom}</td>
            <td>{date}</td>
          </tr>
        </table>
      </div>
      <input
        type='text'
        onChange={(e) =>
          definirNom((precedent) => ({ ...precedent, nom: e.target.value }))
        }
      />
      <input
        type='text'
        onChange={(e) =>
          definirPrenom((precedent) => ({
            ...precedent,
            prenom: e.target.value,
          }))
        }
      />
      <input
        type='date'
        onChange={(e) =>
          definirDate((precedent) => ({ ...precedent, date: e.target.value }))
        }
      />
    </>
  );
}

export default App;
```

Avec cette approche, vous garantissez une gestion robuste et fiable de l'état dans vos applications React.

Voici une explication complète des deux approches et une analyse de pourquoi la deuxième version du code ne fonctionne pas correctement.

---

## une Fonction de Gestion Partagée

### Pourquoi Utiliser une Fonction de Gestion Partagée ?

```jsx
import { useState } from "react";

function App() {
  // États séparés pour chaque champ
  const [nom, definirNom] = useState("");
  const [prenom, definirPrenom] = useState("");
  const [date, definirDate] = useState("");

  // Fonction partagée simplifiée
  const gestionnaireFonctionPartagee = (defenir) => (evenement) => {
    defenir(evenement.target.value);
  };

  return (
    <>
      <div>
        <table>
          <thead>
            <tr>
              <th>Nom</th>
              <th>Prénom</th>
              <th>Date</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>{nom}</td>
              <td>{prenom}</td>
              <td>{date}</td>
            </tr>
          </tbody>
        </table>
      </div>

      {/* Champs d'entrée */}
      <input
        type='text'
        onChange={gestionnaireFonctionPartagee(definirNom)}
        placeholder='Nom'
      />
      <input
        type='text'
        onChange={gestionnaireFonctionPartagee(definirPrenom)}
        placeholder='Prénom'
      />
      <input
        type='date'
        onChange={gestionnaireFonctionPartagee(definirDate)}
        placeholder='Date'
      />
    </>
  );
}

export default App;
```

### Avantages du Partage de la Fonction de Gestion :

1. **Réduction de la Redondance :**

   - Au lieu de définir une fonction `onChange` séparée pour chaque champ, une seule fonction partagée peut gérer tous les changements.
   - Cela simplifie le code, surtout si vous avez de nombreux champs.

2. **Meilleure Lisibilité :**

   - Le comportement est centralisé dans une seule fonction. Cela facilite la compréhension et le débogage.

3. **Réutilisation :**

   - Une fonction partagée est facilement adaptable si de nouveaux champs ou de nouvelles règles de validation doivent être ajoutés.

4. **Encapsulation de la Logique :**
   - Toutes les mises à jour de l’état sont gérées dans un seul endroit, réduisant les risques d’erreurs.

---

## Pourquoi Code Dessous Ne Fonctionne Pas

```jsx
import { useState } from "react";

function App() {
  const [nom, definirNom] = useState("");
  const [prenom, definirPrenom] = useState("");
  const [date, definirDate] = useState("");

  const gestionnaireFonctionPartagee = (identifier, evenement) => {
    /***
     * 1. Mauvaise Utilisation de l'État Précédent
Les états nom, prenom, et date sont des chaînes simples, pas des objets. Pourtant, dans le code, vous utilisez la syntaxe suivante pour essayer de mettre à jour un état :

javascript
Copier le code
definirNom((precedent) => ({
  ...precedent,
  [identifier]: evenement.target.value,
}));
Cette approche est incorrecte car precedent est une chaîne (par exemple, "Jean") et non un objet. La syntaxe de déstructuration (...precedent) n'est pas valide pour une chaîne.
     */
    switch (identifier) {
      case "nom":
        definirNom((precedent) => ({
          ...precedent,
          [identifier]: evenement.target.value,
        }));
        break;
      case "prenom":
        definirPrenom((precedent) => ({
          ...precedent,
          [identifier]: evenement.target.value,
        }));
        break;
      case "date":
        definirDate((precedent) => ({
          ...precedent,
          [identifier]: evenement.target.value,
        }));
        break;
      default:
        break;
    }
  };

  return (
    <>
      <div>
        <table>
          <tr>
            <th>Nom</th>
            <th>Prénom</th>
            <th>Date</th>
          </tr>
          <tr>
            <td>{nom}</td>
            <td>{prenom}</td>
            <td>{date}</td>
          </tr>
        </table>
      </div>

      <input
        type='text'
        onChange={(evenement) => gestionnaireFonctionPartagee("nom", evenement)}
        placeholder='Nom'
      />
      <input
        type='text'
        onChange={(evenement) =>
          gestionnaireFonctionPartagee("prenom", evenement)
        }
        placeholder='Prrenom'
      />
      <input
        type='date'
        onChange={(evenement) =>
          gestionnaireFonctionPartagee("date", evenement)
        }
        placeholder='Date'
      />
    </>
  );
}

export default App;

import { useState } from "react";

function App() {
  const [nom,definirNom] = useState("");
  const [prenom,definirPrenom] = useState("");
  const [date,definirDate] = useState("");

  const gestionnaireFonctionPartagee = (identifier, evenement) => {
    switch (identifier) {
      case "nom":
        definirNom((precedent) => ({
          ...precedent,
          [identifier]: evenement.target.value,
        }));
        break;
      case "prenom":
        definirPrenom((precedent) => ({
          ...precedent,
          [identifier]: evenement.target.value,
        }));
        break;
      case "date":
        definirDate((precedent) => ({
          ...precedent,
          [identifier]: evenement.target.value,
        }));
        break;
      default:
        break;

    }
  }

  return (
    <>
      <div>
        <table>
          <tr>
            <th>Nom</th>
            <th>Prénom</th>
            <th>Date</th>
          </tr>
          <tr>
            <td>{nom}</td>
            <td>{prenom}</td>
            <td>{date}</td>
          </tr>
        </table>
      </div>

     <input type="text" value={nom} onChange={(e) => gestionnaireFonctionPartagee("nom")} placeholder="Nom" />
     <input type="text" value={prenom} onChange={(e) => gestionnaireFonctionPartagee("prenom")} placeholder="Prrenom" />
     <input type="text" value={date} onChange={(e) => gestionnaireFonctionPartagee("date")} placeholder="Date" />
    </>
  );
}

export default App;

```

### Problèmes Identifiés :

1. **Mauvaise Utilisation de l'État Précédent :**

   ```javascript
   definirNom((precedent) => ({
     ...precedent,
     [identifier]: evenement.target.value,
   }));
   ```

   - **Erreur :** Les états `nom`, `prenom` et `date` sont des chaînes simples, pas des objets. Vous ne pouvez pas effectuer de déstructuration (`...precedent`) sur une chaîne.
   - **Impact :** Cela provoque des erreurs car la déstructuration n'est pas applicable à une chaîne de caractères.

2. **Absence de Paramètres dans l'Appel :**

   ```javascript
   onChange={(e) => gestionnaireFonctionPartagee("nom")}
   ```

   - **Erreur :** Vous n'avez pas passé l'événement `e` à `gestionnaireFonctionPartagee`, donc l'appel manque la valeur d'entrée.
   - **Impact :** Les champs ne peuvent pas mettre à jour les états car la valeur de l'entrée utilisateur (`e.target.value`) n'est jamais transmise.

3. **Logique Complexe et Non Nécessaire :**
   - Utiliser un `switch` pour chaque champ et essayer de manipuler directement les chaînes avec une structure d'objet (`...precedent`) est inutilement compliqué.

---

### Soumission de Formulaire en React

Dans l'exemple de code React, le formulaire est soumis en utilisant un gestionnaire d'événements `onSubmit`. Lors de la soumission, le comportement par défaut du formulaire est intercepté pour effectuer une action personnalisée.

#### Étapes de la soumission du formulaire :

1. **Prévention de la soumission par défaut**  
   Lorsque l'utilisateur appuie sur le bouton de soumission (`<button type="submit">Envoyer</button>`), le formulaire est normalement envoyé à un serveur, ce qui provoquerait un rafraîchissement de la page. Pour éviter cela dans une application React (qui vise à maintenir l'état sur la page sans la recharger), la soumission par défaut est **prévenue** grâce à `e.preventDefault()` dans la fonction de soumission. Cela empêche le comportement par défaut du formulaire (envoi du formulaire au serveur).

   ```javascript
   e.preventDefault();
   ```

2. **Création d'un objet avec les données du formulaire**  
   Une fois que l'événement de soumission est capturé, les données des champs de formulaire sont collectées. Dans cet exemple, les valeurs des champs `nom`, `prenom`, et `date` sont extraites des états correspondants, et un objet `personne` est créé pour contenir ces valeurs.

   ```javascript
   const personne = { nom, prenom, date };
   ```

3. **Affichage ou traitement des données**  
   Après la création de l'objet `personne`, les données peuvent être envoyées à un serveur, utilisées pour une autre logique métier, ou simplement affichées dans la console pour vérification.

   ```javascript
   console.log("Form soumis", personne);
   ```

### Pourquoi utiliser `e.preventDefault()` ?

- **Empêcher le rafraîchissement de la page :**  
   Par défaut, un formulaire HTML provoque un rafraîchissement de la page lorsqu'il est soumis. En utilisant `e.preventDefault()`, vous vous assurez que l'application ne recharge pas la page, permettant ainsi de traiter les données sans perte d'état.

- **Contrôle sur la soumission des données :**  
   Cette méthode vous permet de définir le comportement de soumission du formulaire et de gérer les données de manière plus flexible, par exemple en les envoyant via une requête `fetch` ou en les traitant localement dans l'application.

---

### Exemple complet avec soumission personnalisée :

Voici l'exemple de code complet avec une explication détaillée de la soumission du formulaire :

```javascript
import { useState } from "react";

function App() {
  // États séparés pour chaque champ
  const [nom, definirNom] = useState("");
  const [prenom, definirPrenom] = useState("");
  const [date, definirDate] = useState("");

  // Fonction partagée pour gérer les événements des champs de formulaire
  const gestionnaireDeEventdeNom = (event) => {
    definirNom(event.target.value);
  };
  const gestionnaireDeEventdePrenom = (event) => {
    definirPrenom(event.target.value);
  };
  const gestionnaireDeEventdeDate = (event) => {
    definirDate(event.target.value);
  };

  // Fonction de soumission du formulaire
  const handleSubmit = (e) => {
    e.preventDefault(); // Empêcher le comportement de soumission par défaut
    const personne = { nom, prenom, date }; // Créer l'objet contenant les données
    console.log("Form soumis", personne); // Afficher les données dans la console
  };

  return (
    <>
      <form onSubmit={handleSubmit}>
        {" "}
        {/* Attacher le gestionnaire à la soumission du formulaire */}
        <button type='submit'>Envoyer</button>
        <br />
        <input
          type='text'
          value={nom}
          onChange={gestionnaireDeEventdeNom}
          placeholder='Nom'
        />
        <input
          type='text'
          value={prenom}
          onChange={gestionnaireDeEventdePrenom}
          placeholder='Prénom'
        />
        <input
          type='date'
          value={date}
          onChange={gestionnaireDeEventdeDate}
          placeholder='Date'
        />
      </form>
    </>
  );
}

export default App;
```

#### Résumé :

- Le formulaire est soumis avec un bouton qui déclenche l'événement `onSubmit`.
- `e.preventDefault()` empêche le formulaire de se soumettre de manière classique (sans recharger la page).
- Les valeurs des champs du formulaire sont récupérées à partir des états `nom`, `prenom`, et `date` et sont envoyées sous forme d'un objet.
- L'objet `personne` est ensuite affiché dans la console.

### Avantages :

- Cela permet une gestion fluide et moderne des formulaires dans React sans perdre l'état de l'application.
- Vous avez un contrôle total sur la manière dont les données sont collectées et traitées lors de la soumission du formulaire.

```jsx
import { useState } from "react";

function App() {
  // États séparés pour chaque champ
  const [nom, definirNom] = useState("");
  const [prenom, definirPrenom] = useState("");
  const [date, definirDate] = useState("");
  /***
   * 
   * Le problème se situe dans vos gestionnaires d'événements (gestionnaireDeEventdeNom, gestionnaireDeEventdePrenom, gestionnaireDeEventdeDate). Ces gestionnaires essaient de mettre à jour les états nom, prenom, et date comme s'ils étaient des objets. Cependant, vos états sont des chaînes simples (strings), pas des objets. Lorsque vous essayez de déstructurer avec ...precedent, cela ne fonctionne pas comme prévu, et l'état devient un objet complexe, ce qui conduit à l'affichage [object Object].

Pourquoi [object Object] s'affiche ?
Quand vous faites ceci dans un gestionnaire d'événements :

javascript
Copier le code
definirNom((precedent) => ({
  ...precedent,
  nom: evenement.target.value,
}));
Problème de structure de données :

precedent est une chaîne, mais vous l'utilisez comme un objet.
En essayant de déstructurer une chaîne avec ...precedent, JavaScript crée un objet malformé.
L'état nom devient un objet (par exemple, { nom: "valeur saisie" }) au lieu d'une chaîne.
Impact sur l'affichage :

Lorsque React essaie d'afficher {nom} (maintenant un objet) dans le JSX, il le convertit en [object Object] parce que les objets ne peuvent pas être affichés directement.

   */

  const gestionnaireDeEventdeNom = (evenement) => {
    definirNom((precedent) => ({
      ...precedent,
      nom: evenement.target.value,
    }));
  };

  const gestionnaireDeEventdePrenom = (evenement) => {
    definirPrenom((precedent) => ({
      ...precedent,
      prenom: evenement.target.value,
    }));
  };

  const gestionnaireDeEventdeDate = (evenement) => {
    definirDate((precedent) => ({
      ...precedent,
      date: evenement.target.value,
    }));
  };

  return (
    <>
      <form
        onSubmit={(e) => {
          e.preventDefault();
          const personne = { nom, prenom, date };
          console.log("Form soumis", personne);
        }}
      >
        <br />
        <button type='submit'>Envoyer</button>
        <br />
        <input type='text' value={nom} onChange={gestionnaireDeEventdeNom} />
        <input
          type='text'
          value={prenom}
          onChange={gestionnaireDeEventdePrenom}
        />
        <input type='date' value={date} onChange={gestionnaireDeEventdeDate} />
      </form>
    </>
  );
}

export default App;
```

### Passer des Données de l'Enfant au Parent en React

Dans React, la communication entre composants se fait généralement dans une direction : de **parent vers enfant** via les **props**. Cependant, dans certains cas, il est nécessaire de faire l'inverse, c'est-à-dire que l'**enfant** doit envoyer des données ou notifier le **parent** de certains événements. Cette communication se fait généralement par le biais de **callbacks** passés du parent à l'enfant via les **props**.

#### Comment ça fonctionne ?

1. **Le parent passe une fonction à l'enfant** : Le parent définit une fonction (callback) qui sera utilisée pour recevoir les données de l'enfant.
2. **L'enfant appelle la fonction** : L'enfant utilise cette fonction pour envoyer des informations au parent, généralement en réponse à une interaction utilisateur (par exemple, un clic sur un bouton ou une modification d'un champ de saisie).

Cette technique permet de faire circuler des données de l'enfant vers le parent tout en respectant le flux de données unidirectionnel de React.

### Exemple de Passation de Données de l'Enfant au Parent :

#### 1. Composant Parent :

Le parent crée une fonction qui sera appelée par l'enfant pour envoyer les données.

```jsx
import { useState } from "react";
import Enfant from "./Enfant";

function App() {
  const [dataSauvegardee, definirDataSauvegardee] = useState({});

  const gestionnaireDeData = (dataEntree) => {
    definirDataSauvegardee({
      ...dataEntree,
      id: Math.random().toString(),
    });
    console.log(dataSauvegardee);
  };

  return (
    <>
      <Enfant envoyerData={gestionnaireDeData} />
      <p> {JSON.stringify(dataSauvegardee)} </p>
    </>
  );
}

export default App;
```

#### 2. Composant Enfant :

L'enfant appelle la fonction passée par le parent lorsqu'un événement se produit (par exemple, un clic sur un bouton).

```jsx
import { useState } from "react";
export default function Enfant(props) {
  // États séparés pour chaque champ
  const [nom, definirNom] = useState("");
  const [prenom, definirPrenom] = useState("");

  const gesttionaireSoumission = (e) => {
    e.preventDefault(); // Empêcher le comportement de soumission par défaut
    props.envoyerData({ nom, prenom });
  };

  return (
    <div>
      <input
        type='text'
        value={nom}
        onChange={(e) => definirNom(e.target.value)}
      />
      <input
        type='text'
        value={prenom}
        onChange={(e) => definirPrenom(e.target.value)}
      />
      <button onClick={gesttionaireSoumission}>Soumettre</button>
    </div>
  );
}
```

### Pourquoi utiliser cette approche ?

- **Unidirectionnalité des données** : React privilégie un flux de données unidirectionnel. Même si l'on veut faire remonter des données de l'enfant au parent, il est nécessaire de passer par des **callbacks**. Cela garde la structure des données claire et évite la confusion.
- **Contrôle centralisé** : Le parent garde toujours le contrôle sur les données. L'enfant ne fait que transmettre des informations ou notifier le parent, qui peut alors prendre des décisions en fonction de ces informations.
- **Réutilisabilité** : Cette approche permet de rendre les composants enfants plus réutilisables, car ils ne sont pas directement responsables de la gestion des données ou des mises à jour d'état complexes. Ils sont simplement des émetteurs d'événements.

### Concept Général de la Gestion de l'État et du Flux de Données dans React

Dans une application React, la gestion de l'état et le passage des données entre les composants sont des concepts clés qui influencent le comportement et la structure de l'application. Voici une explication détaillée du mécanisme général de gestion de l'état et de son flux dans React :

#### 1. **L'État dans React :**

L'état (state) est une structure qui permet de stocker des informations locales à un composant. Chaque composant React peut avoir son propre état, qui définit sa représentation et son comportement à un moment donné. L'état peut être modifié en réponse à des événements ou des interactions avec l'utilisateur, et ces changements d'état entraînent généralement une re-rendu (render) du composant pour refléter les nouvelles données.

- **Exemple :** Un champ de formulaire où l'utilisateur entre son nom et son prénom. L'état du composant contiendra ces valeurs, et toute modification sera mise à jour dynamiquement à l'écran.

#### 2. **Flux de Données unidirectionnel (One-way Data Flow) :**

React suit un principe de flux de données unidirectionnel, c'est-à-dire que les données circulent toujours dans une seule direction : du **parent vers l'enfant** via des **props**. Ce flux est essentiel pour maintenir une logique de gestion d'état prévisible et simple.

- **De l'état local à l'enfant :** Le composant parent gère l'état, puis transmet les données à ses composants enfants sous forme de **props**. Les enfants peuvent alors utiliser ces données, mais ne peuvent pas les modifier directement.
- **Des enfants vers le parent :** Si un enfant doit modifier l'état, il le fait en invoquant une fonction du parent (généralement passée sous forme de props). Cela permet au parent de mettre à jour l'état global.

Ce flux garantit que l'état reste cohérent et permet une gestion prévisible des changements de données dans l'application.

#### 3. **Communication entre Composants :**

- **De l'enfant au parent (via une fonction callback) :** Lorsqu'un enfant doit modifier l'état global, il invoque une fonction de rappel (callback) fournie par le parent. Cela permet au parent de mettre à jour l'état et de propager la nouvelle donnée à tous les autres composants enfants qui en ont besoin.
- **De parent à enfant (via des props) :** Le parent transmet les données ou l'état sous forme de props aux enfants. Les enfants ne peuvent pas modifier ces données directement, mais ils peuvent les afficher ou les utiliser.

#### 4. **Pourquoi ne pas gérer l'état dans plusieurs composants enfants ?**

Si l'état est géré indépendamment dans plusieurs composants enfants, cela peut entraîner des incohérences et des erreurs difficiles à déboguer, car chaque composant pourrait avoir une copie locale de l'état, avec des valeurs différentes.

- Par exemple, si chaque enfant a une copie de l'état mais que les enfants ne sont pas informés des changements d'état dans les autres enfants, cela peut provoquer des erreurs de synchronisation des données.
- La solution consiste à centraliser la gestion de l'état dans un composant parent, ce qui garantit que toutes les données sont cohérentes et qu'elles peuvent être partagées entre les composants enfants.

#### 5. **Avis :**

- **Centralisation de l'état :** Le parent doit gérer l'état et le partager avec ses enfants via les props. Cela permet d'éviter la duplication de l'état et de garder une source unique de vérité.
- **Fonctions de rappel (callbacks) :** Les composants enfants doivent faire appel aux fonctions du parent pour modifier l'état. Cela permet de maintenir un flux de données cohérent et contrôlé.
- **Unidirectionnalité des données :** Respecter le principe de l'unidirectionnalité du flux de données permet de mieux comprendre le cycle de vie de l'état et de prévenir les erreurs.

### Schéma général de l'architecture de l'état :

```
App (Parent)
   ├── State (géré ici)
   ├── Passé à un enfant via props
   └── Fonction callback pour la mise à jour de l'état
       └── Enfant modifie l'état via la fonction du parent
```

Le concept clé dans React est la gestion de l'état de manière unidirectionnelle et centralisée. Cela permet de garder le contrôle sur l'état global de l'application et d'éviter les incohérences. En centralisant l'état dans un composant parent, les autres composants enfants peuvent accéder aux données via des props et envoyer des événements pour mettre à jour l'état sans en être responsables directement. Ce modèle facilite la maintenance, le débogage et la gestion des données dans des applications complexes.

### Qu'est-ce que le **"computed state"** dans React ?

Le **"computed state"** (ou état calculé) dans React fait référence à une valeur qui est dérivée d'autres valeurs de l'état au lieu d'être définie directement par l'utilisateur ou une interaction. C'est une forme d'état qui n'est pas stockée de manière explicite, mais plutôt calculée en fonction de l'état existant ou des props du composant.

### Principe de fonctionnement

Dans React, l'état est généralement utilisé pour stocker des données qui peuvent changer au fil du temps. Le **computed state** est une approche où l'on déduit une valeur de l'état à partir d'autres données, plutôt que de la stocker directement dans l'état.

#### Exemple classique de computed state :

Imaginez une situation où vous avez un formulaire qui prend une valeur d'âge et que vous voulez calculer si la personne est majeure ou mineure. Au lieu de stocker cette information ("majeur" ou "mineur") dans l'état, vous pouvez simplement la calculer à partir de l'âge, chaque fois qu'il est mis à jour.

### Exemple de code avec computed state

```javascript
import { useState } from "react";

function App() {
  const [age, definirAge] = useState(0);

  let compteAge = age >= 18 ? "Majeur" : "Mineur";

  return (
    <>
      <input
        type='number'
        value={age}
        onChange={(e) => definirAge(e.target.value)}
      />

      <p>Statut : {compteAge}</p>
    </>
  );
}

export default App;
```

Dans cet exemple, le statut ("Majeur" ou "Mineur") est un **computed state**, qui dépend directement de la valeur de l'**âge**. L'état `statut` n'est pas stocké, mais il est calculé chaque fois que l'âge change.

### Pourquoi utiliser un **computed state** ?

1. **Réduire la duplication des données :** Vous n'avez pas besoin de stocker des informations dérivées (comme `statut`) dans l'état, car vous pouvez les calculer à la volée à partir des autres états ou props.
2. **Réactivité automatique :** Le computed state peut automatiquement être recalculé chaque fois que l'état ou les props sur lesquels il dépend changent, sans avoir besoin d'une mise à jour manuelle.
3. **Simplification du code :** Au lieu de gérer des valeurs supplémentaires dans l'état, vous calculez directement des valeurs dérivées dans le corps du composant ou dans des fonctions auxiliaires, ce qui peut rendre le code plus lisible et plus facile à maintenir.

### Utilisation avec `useMemo`

Dans certains cas où le calcul peut être coûteux (par exemple, des calculs complexes ou des transformations de données volumineuses), vous pouvez utiliser le hook `useMemo` pour mémoriser le résultat du calcul afin qu'il ne soit effectué que lorsque les dépendances changent. Cela améliore les performances.

```javascript
import { useMemo, useState } from "react";

function App() {
  const [age, definirAge] = useState(0);

  const status = useMemo(() => {
    return age >= 18 ? "Majeur" : "Mineur";
  }, [age]);

  return (
    <>
      <input
        type='number'
        value={age}
        onChange={(e) => definirAge(e.target.value)}
      />

      <p>Statut : {status}</p>
    </>
  );
}

export default App;
```

Le **computed state** dans React est un état dérivé qui est calculé à partir de l'état ou des props existants, et qui peut être mis à jour de manière réactive lorsque les données sous-jacentes changent. Cela permet de simplifier l'application en évitant de stocker des données redondantes et permet à votre application de rester performante et facile à maintenir.

### **Controlled Component** (Composant Contrôlé)

Un **composant contrôlé** est un composant React dont l'état (ou la valeur) est entièrement contrôlé par le composant parent via **props**. L'état du composant est lié à une variable d'état dans le parent, et toute modification de la valeur dans le composant enfant est synchronisée avec l'état du parent. Cela permet au parent de gérer l'ensemble de l'état et de s'assurer que la valeur affichée dans le composant est toujours en phase avec l'état du parent.

#### Exemple de composant contrôlé :

```javascript
import { useState } from "react";

function App() {
  const [nom, setNom] = useState("");

  // Gérer la mise à jour de l'état à partir du champ de saisie
  const handleChange = (event) => {
    setNom(event.target.value);
  };

  return (
    <div>
      <input
        type='text'
        value={nom} // La valeur est contrôlée par l'état du parent
        onChange={handleChange}
      />
      <p>Nom: {nom}</p>
    </div>
  );
}

export default App;
```

### **Uncontrolled Component** (Composant Non Contrôlé)

Un **composant non contrôlé** est un composant dont l'état (ou la valeur) est géré de manière indépendante, généralement par le DOM lui-même. Dans un composant non contrôlé, React ne gère pas directement l'état de la valeur du champ de saisie. Au lieu de cela, vous utilisez une **référence (ref)** pour accéder directement à l'élément DOM et récupérer sa valeur.

#### Exemple de composant non contrôlé :

```jsx

```

### Différences Clés :

1. **Contrôle de l'état :**

   - **Composant contrôlé** : L'état de l'élément (comme la valeur d'un champ de formulaire) est contrôlé par React et l'état du composant parent.
   - **Composant non contrôlé** : L'état de l'élément est géré par le DOM, et React n'a pas de contrôle direct sur la valeur du champ de saisie.

2. **Gestion de la valeur :**

   - **Composant contrôlé** : La valeur d'un champ est liée à un état via `value` et mise à jour avec `onChange`.
   - **Composant non contrôlé** : La valeur d'un champ est récupérée via une référence (`ref`) et peut être manipulée sans déclencher un re-render.

3. **Cas d'utilisation :**
   - **Composant contrôlé** : Idéal pour des formulaires où vous avez besoin de valider ou manipuler les valeurs en temps réel.
   - **Composant non contrôlé** : Utile pour des situations où vous n'avez pas besoin de synchroniser constamment l'état avec l'interface, comme lors de l'intégration de bibliothèques externes ou de la gestion de petites interactions.

```jsx
import { useRef } from "react";

function App() {
  const monRef = useRef();

  //  <p>{monRef.current.value}</p>
  /***
   * Le problème avec votre code est que vous tentez d'afficher la valeur de l'élément de formulaire (monRef.current.value) directement dans le JSX sans attendre que l'utilisateur interagisse avec l'élément. Lors du premier rendu du composant, monRef.current est null, car React n'a pas encore lié la référence (ref) à l'élément DOM. Ainsi, accéder à monRef.current.value avant que l'élément ne soit rendu causera une erreur, car la référence n'est pas encore disponible.
   */

  return (
    <>
      <input type='text' ref={monRef} />
      <button onClick={() => alert("Nom soumis: " + monRef.current.value)}>
        Focus
      </button>
    </>
  );
}

export default App;
```

- **Composant contrôlé** : La gestion de l'état se fait via React (par les props et `useState`), et l'interface est toujours synchronisée avec l'état du composant parent.
- **Composant non contrôlé** : L'état est géré en dehors de React, en utilisant des références directes aux éléments DOM.
