### Authentification

#### Obtenir des permissions

L'authentification est un processus qui permet à un client de prouver son identité pour accéder à des ressources protégées sur un serveur. Voici les approches courantes :

1. **Client et requêtes avec des identifiants :**
   - Le client envoie ses identifiants (par exemple, nom d'utilisateur et mot de passe) au serveur pour vérifier son identité.
   - Cependant, il est risqué de sauvegarder ou de transmettre directement des identifiants, car cela peut exposer ces informations sensibles.
   - Envoyer des informations fausses ou malveillantes peut compromettre la sécurité du serveur.

---

#### Approche basée sur les sessions

- **Serveur Sessions :**
  - Le serveur crée un identifiant unique (session ID) après authentification réussie.
  - Cet identifiant est stocké côté serveur et envoyé au client.
  - Le client renvoie cet identifiant avec chaque requête ultérieure pour accéder aux ressources protégées.
  - Cela permet au serveur de valider les requêtes en comparant l'identifiant envoyé avec celui qu'il a en mémoire.

---

#### Approche basée sur les tokens

- **Tokens d'authentification :**
  - Le serveur génère un token d'authentification après validation des identifiants.
  - Contrairement aux sessions, le serveur ne conserve pas de token côté serveur.
  - Le token est envoyé au client, qui doit le renvoyer avec chaque requête pour accéder aux ressources protégées.
  - Le serveur utilise des algorithmes de validation pour vérifier que le token est authentique et n'a pas expiré.

---

Chacune de ces approches a ses avantages et inconvénients selon les besoins en sécurité et en performance. Les tokens sont souvent utilisés pour les applications modernes, notamment avec OAuth ou JWT.

### Page de Connexion (Ouvrir une Session)

Une page de connexion est essentielle pour toute application nécessitant une authentification des utilisateurs. Elle permet aux utilisateurs de saisir leurs identifiants pour accéder aux ressources protégées de l'application. Voici une implémentation simple d'une page de connexion dans React.

```jsx
import React, { useState } from 'react';

const AuthPage = () => {
  const [isSignup, setIsSignup] = useState(false); // Basculer entre Connexion et Inscription
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [username, setUsername] = useState(''); // Utilisé uniquement pour l'inscription
  const [confirmPassword, setConfirmPassword] = useState(''); // Utilisé uniquement pour l'inscription

  const handleSubmit = (e) => {
    e.preventDefault();
    if (isSignup) {
      // Logique d'inscription
      if (password !== confirmPassword) {
        alert('Les mots de passe ne correspondent pas !');
        return;
      }
      console.log('Inscription réussie :', { username, email, password });
      alert('Compte créé avec succès !');
    } else {
      // Logique de connexion
      console.log('Connexion réussie :', { email, password });
      alert('Connexion réussie !');
    }

    // Réinitialiser les champs
    setEmail('');
    setPassword('');
    setUsername('');
    setConfirmPassword('');
  };

  return (
    <div style={{ maxWidth: '400px', margin: '50px auto', padding: '20px', border: '1px solid #ddd', borderRadius: '5px' }}>
      <h2>{isSignup ? "Créer un Compte" : "Se Connecter"}</h2>
      <form onSubmit={handleSubmit}>
        {isSignup && (
          <div style={{ marginBottom: '15px' }}>
            <label htmlFor="username" style={{ display: 'block', marginBottom: '5px' }}>Nom d'utilisateur :</label>
            <input
              type="text"
              id="username"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              placeholder="Entrez votre nom d'utilisateur"
              required={isSignup}
              style={{ width: '100%', padding: '8px', border: '1px solid #ccc', borderRadius: '5px' }}
            />
          </div>
        )}
        <div style={{ marginBottom: '15px' }}>
          <label htmlFor="email" style={{ display: 'block', marginBottom: '5px' }}>Email :</label>
          <input
            type="email"
            id="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="Entrez votre email"
            required
            style={{ width: '100%', padding: '8px', border: '1px solid #ccc', borderRadius: '5px' }}
          />
        </div>
        <div style={{ marginBottom: '15px' }}>
          <label htmlFor="password" style={{ display: 'block', marginBottom: '5px' }}>Mot de passe :</label>
          <input
            type="password"
            id="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Entrez votre mot de passe"
            required
            style={{ width: '100%', padding: '8px', border: '1px solid #ccc', borderRadius: '5px' }}
          />
        </div>
        {isSignup && (
          <div style={{ marginBottom: '15px' }}>
            <label htmlFor="confirmPassword" style={{ display: 'block', marginBottom: '5px' }}>Confirmez le mot de passe :</label>
            <input
              type="password"
              id="confirmPassword"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              placeholder="Confirmez votre mot de passe"
              required={isSignup}
              style={{ width: '100%', padding: '8px', border: '1px solid #ccc', borderRadius: '5px' }}
            />
          </div>
        )}
        <button
          type="submit"
          style={{
            backgroundColor: isSignup ? '#28a745' : '#007BFF',
            color: '#fff',
            border: 'none',
            padding: '10px 15px',
            borderRadius: '5px',
            cursor: 'pointer',
          }}
        >
          {isSignup ? "S'inscrire" : "Se Connecter"}
        </button>
      </form>
      <p style={{ marginTop: '15px', textAlign: 'center' }}>
        {isSignup ? "Vous avez déjà un compte ?" : "Vous n'avez pas de compte ?"}{' '}
        <button
          onClick={() => setIsSignup(!isSignup)}
          style={{
            background: 'none',
            border: 'none',
            color: '#007BFF',
            textDecoration: 'underline',
            cursor: 'pointer',
            padding: 0,
          }}
        >
          {isSignup ? "Se Connecter" : "S'inscrire"}
        </button>
      </p>
    </div>
  );
};

export default AuthPage;
import React from 'react';

import AuthPage from './AuthPage';



// Application principale avec RouterProvider
const App = () => {
  return (
   <AuthPage />
  );
};

export default App;

```

#### Fonctionnement Étape par Étape

1. **Saisie des Identifiants** : Les utilisateurs saisissent leur email et mot de passe dans les champs appropriés.
2. **Validation de Base** : Les champs sont obligatoires grâce à l'attribut `required`.
3. **Soumission du Formulaire** : Lorsqu'un utilisateur clique sur le bouton _Se Connecter_, la fonction `handleSubmit` est déclenchée.
4. **Traitement des Données** : Les identifiants sont traités, et vous pouvez implémenter une logique supplémentaire (exemple : envoi à un serveur pour validation).
5. **Confirmation** : Une alerte ou un message peut confirmer la connexion réussie.

#### Points Clés

- **Simplicité** : Cette implémentation est minimaliste et facile à personnaliser.
- **Extensibilité** : Ajoutez des validations supplémentaires, des messages d'erreur ou des intégrations API selon les besoins.
- **Style** : Les styles inline offrent une mise en page rapide, mais peuvent être remplacés par des frameworks CSS comme Bootstrap ou Tailwind CSS.

Cette page constitue une base solide pour démarrer avec l'authentification dans une application React.

### `useSearchParams()` : Gestion des paramètres de recherche dans React Router

#### Qu'est-ce que `useSearchParams()` ?

`useSearchParams()` est un hook fourni par React Router pour gérer les paramètres de recherche (query parameters) dans l'URL. Il permet de lire, de modifier et de manipuler ces paramètres directement dans les composants React.

---

#### Syntaxe de Base

```javascript
const [searchParams, setSearchParams] = useSearchParams();
```

- **`searchParams`** : Un objet représentant les paramètres de recherche actuels de l'URL, similaire à `URLSearchParams`.
- **`setSearchParams`** : Une fonction pour mettre à jour ou remplacer les paramètres de recherche.

---

#### Utilisation Étape par Étape

1. **Lecture des Paramètres de Recherche** :

   - Récupérez les valeurs actuelles des paramètres dans l'URL.

   ```javascript
   import { useSearchParams } from "react-router-dom";

   const MyComponent = () => {
     const [searchParams] = useSearchParams();
     const paramValue = searchParams.get("key"); // Récupère la valeur du paramètre "key"

     return <div>Valeur de "key" : {paramValue}</div>;
   };
   ```

2. **Mise à Jour des Paramètres de Recherche** :

   - Ajoutez, modifiez ou supprimez des paramètres en utilisant `setSearchParams`.

   ```javascript
   import { useSearchParams } from "react-router-dom";

   const MyComponent = () => {
     const [searchParams, setSearchParams] = useSearchParams();

     const handleUpdate = () => {
       setSearchParams({ key: "newValue", anotherKey: "123" }); // Met à jour les paramètres
     };

     return (
       <div>
         <button onClick={handleUpdate}>Mettre à jour les paramètres</button>
       </div>
     );
   };
   ```

3. **Ajout ou Modification Partielle des Paramètres** :

   - Conservez les paramètres existants tout en modifiant un seul.

   ```javascript
   import { useSearchParams } from "react-router-dom";

   const MyComponent = () => {
     const [searchParams, setSearchParams] = useSearchParams();

     const addOrUpdateParam = () => {
       const updatedParams = new URLSearchParams(searchParams);
       updatedParams.set("newKey", "value123");
       setSearchParams(updatedParams);
     };

     return (
       <button onClick={addOrUpdateParam}>
         Ajouter ou Modifier un Paramètre
       </button>
     );
   };
   ```

4. **Suppression d'un Paramètre de Recherche** :

   - Supprimez un paramètre spécifique de l'URL.

   ```javascript
   const removeParam = () => {
     const updatedParams = new URLSearchParams(searchParams);
     updatedParams.delete("keyToRemove");
     setSearchParams(updatedParams);
   };
   ```

---

#### Exemple Complet

```javascript
import React from "react";
import { useSearchParams } from "react-router-dom";

const SearchParamsDemo = () => {
  const [searchParams, setSearchParams] = useSearchParams();

  const addParam = () => {
    const updatedParams = new URLSearchParams(searchParams);
    updatedParams.set("newParam", "exampleValue");
    setSearchParams(updatedParams);
  };

  const removeParam = () => {
    const updatedParams = new URLSearchParams(searchParams);
    updatedParams.delete("newParam");
    setSearchParams(updatedParams);
  };

  return (
    <div>
      <h2>Paramètres de recherche actuels :</h2>
      <pre>{searchParams.toString()}</pre>
      <button onClick={addParam}>Ajouter un Paramètre</button>
      <button onClick={removeParam}>Supprimer un Paramètre</button>
    </div>
  );
};

export default SearchParamsDemo;
```

---

#### Points Clés à Noter

1. **Comportement Réactif** :

   - Toute modification des paramètres dans `setSearchParams` provoque un re-rendu du composant.

2. **Navigation** :

   - `useSearchParams` ne recharge pas la page entière mais modifie l'URL dans l'historique du navigateur.

3. **URL Encodée** :
   - Les paramètres sont automatiquement encodés pour éviter les problèmes de syntaxe.

---

#### Cas d'Utilisation Commun

1. **Filtres dans une Page de Recherche** :

   - Exemple : `/products?category=shoes&size=42`.

2. **Gestion des Pages** :

   - Exemple : `/list?page=2`.

3. **Partage d'États via l'URL** :
   - Exemple : `/dashboard?theme=dark`.

---

En combinant `useSearchParams()` avec d'autres hooks et composants, vous pouvez créer des interfaces dynamiques basées sur l'URL.

### Actions d'authentification

**actions d'authentification** dans une application React en utilisant **Redux**. L’objectif ici est de gérer les actions de connexion, inscription et déconnexion.

---

### **Étape 1 : Installer les dépendances nécessaires**

Si vous n'avez pas encore installé Redux et React-Redux, vous devez d'abord ajouter ces paquets à votre projet :

```bash
npm install redux react-redux
```

---

### **Étape 2 : Créer les Actions d'authentification**

Les actions représentent les différentes opérations possibles sur l'état, telles que la connexion, l'inscription, la déconnexion et les erreurs.

1. Créez un fichier pour vos actions : `authActions.js`.

```javascript
// actions/authActions.js

export const loginSuccess = (user) => ({
  type: "LOGIN_SUCCESS",
  payload: user,
});

export const loginFailure = (error) => ({
  type: "LOGIN_FAILURE",
  payload: error,
});

export const logout = () => ({
  type: "LOGOUT",
});

export const signupSuccess = (user) => ({
  type: "SIGNUP_SUCCESS",
  payload: user,
});

export const signupFailure = (error) => ({
  type: "SIGNUP_FAILURE",
  payload: error,
});
```

- **`loginSuccess` et `signupSuccess`** : Ces actions sont appelées après une connexion ou inscription réussie. Elles transmettent l'utilisateur authentifié.
- **`loginFailure` et `signupFailure`** : Ces actions sont appelées en cas d'échec de l'authentification (par exemple, mauvais mot de passe).
- **`logout`** : Action qui efface l'état de l'utilisateur lorsque l'utilisateur se déconnecte.

---

### **Étape 3 : Créer le Réducteur d'authentification**

Un réducteur gère l'état de l'application en fonction des actions envoyées. Il met à jour l'état à chaque fois qu'une action est dispatchée.

1. Créez un fichier pour votre réducteur : `authReducer.js`.

```javascript
// reducers/authReducer.js

const initialState = {
  user: null,
  isAuthenticated: false,
  error: null,
  loading: false,
};

const authReducer = (state = initialState, action) => {
  switch (action.type) {
    case "LOGIN_SUCCESS":
      return {
        ...state,
        user: action.payload,
        isAuthenticated: true,
        error: null,
      };
    case "LOGIN_FAILURE":
      return {
        ...state,
        error: action.payload,
        isAuthenticated: false,
      };
    case "SIGNUP_SUCCESS":
      return {
        ...state,
        user: action.payload,
        isAuthenticated: true,
        error: null,
      };
    case "SIGNUP_FAILURE":
      return {
        ...state,
        error: action.payload,
        isAuthenticated: false,
      };
    case "LOGOUT":
      return {
        ...state,
        user: null,
        isAuthenticated: false,
      };
    default:
      return state;
  }
};

export default authReducer;
```

- **InitialState** : Le tableau initial de l’état avec l’utilisateur `null`, un indicateur `isAuthenticated` à `false` et aucun message d’erreur.
- **Les cases de chaque action** : Chaque action modifie l’état de manière spécifique (connexion, échec, inscription, déconnexion).

---

### **Étape 4 : Configurer le Store Redux**

Maintenant, vous devez combiner votre réducteur avec le store global de Redux. Cela permet à votre application de gérer l'état global de l'authentification.

1. Créez ou modifiez votre fichier `store.js` :

```javascript
// store.js
import { createStore, combineReducers } from "redux";
import authReducer from "./reducers/authReducer";

const rootReducer = combineReducers({
  auth: authReducer,
});

const store = createStore(rootReducer);

export default store;
```

Le `combineReducers` permet de combiner plusieurs réducteurs si vous en avez plusieurs dans votre application.

---

### **Étape 5 : Fournir le Store à l'application**

Pour que Redux fonctionne dans votre application React, vous devez envelopper votre application avec le `Provider` de **React-Redux** pour accéder au store global.

1. Modifiez votre fichier `index.js` ou `App.js` pour inclure le **Provider**.

```javascript
// index.js ou App.js
import React from "react";
import ReactDOM from "react-dom";
import { Provider } from "react-redux";
import store from "./store";
import AuthPage from "./AuthPage";

ReactDOM.render(
  <Provider store={store}>
    <AuthPage />
  </Provider>,
  document.getElementById("root")
);
```

---

### **Étape 6 : Utiliser les Actions dans les Composants**

Vous pouvez maintenant utiliser ces actions dans vos composants pour gérer l'authentification. Par exemple, dans un composant `AuthPage`, vous pouvez appeler les actions de connexion et d'inscription.

```javascript
// AuthPage.js

import React, { useState } from "react";
import { useDispatch } from "react-redux";
import {
  loginSuccess,
  loginFailure,
  signupSuccess,
  signupFailure,
} from "./actions/authActions";

const AuthPage = () => {
  const dispatch = useDispatch();
  const [isSignup, setIsSignup] = useState(false);
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [username, setUsername] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (isSignup) {
      // Logic for signup
      if (password !== confirmPassword) {
        alert("Les mots de passe ne correspondent pas !");
        return;
      }

      try {
        // Make API call to signup
        const response = await fetch("/api/signup", {
          method: "POST",
          body: JSON.stringify({ username, email, password }),
        });

        if (response.ok) {
          const user = await response.json();
          dispatch(signupSuccess(user)); // Dispatch signup success
          alert("Inscription réussie!");
        } else {
          const error = await response.json();
          dispatch(signupFailure(error)); // Dispatch signup failure
          alert("Erreur lors de l'inscription!");
        }
      } catch (error) {
        dispatch(signupFailure(error));
        alert("Erreur réseau!");
      }
    } else {
      // Logic for login
      try {
        const response = await fetch("/api/login", {
          method: "POST",
          body: JSON.stringify({ email, password }),
        });

        if (response.ok) {
          const user = await response.json();
          dispatch(loginSuccess(user)); // Dispatch login success
          alert("Connexion réussie!");
        } else {
          const error = await response.json();
          dispatch(loginFailure(error)); // Dispatch login failure
          alert("Erreur lors de la connexion!");
        }
      } catch (error) {
        dispatch(loginFailure(error));
        alert("Erreur réseau!");
      }
    }
  };

  return (
    <div>
      {/* Formulaire */}
      <button onClick={handleSubmit}>
        {isSignup ? "S'inscrire" : "Se connecter"}
      </button>
    </div>
  );
};

export default AuthPage;
```

- **`dispatch`** : Utilisé pour envoyer des actions. Il prend une action en paramètre (par exemple, `signupSuccess` ou `loginFailure`).
- **API Call** : Vous effectuez un appel API pour envoyer les données et obtenir une réponse (vous pouvez utiliser `fetch` ou une bibliothèque comme `axios`).

---

### **Étape 7 : Gérer la Déconnexion**

La déconnexion réinitialise l'état de l'utilisateur en dispatchant l'action `logout`.

```javascript
// Déconnexion
const handleLogout = () => {
  dispatch(logout());
};
```

Cela supprime l'utilisateur du store et met à jour l'état global.

---

### Conclusion

Ce guide vous aide à comprendre comment gérer l'authentification avec Redux dans une application React. Vous avez vu comment créer des actions, gérer les données dans un réducteur et connecter votre store à vos composants pour gérer la connexion, l'inscription et la déconnexion.

- **Actions** : Gèrent l'envoi de données pour la connexion et l'inscription.
- **Réducteur** : Met à jour l'état global de l'authentification.
- **Dispatch** : Utilisé pour envoyer les actions dans vos composants.

Cette approche vous permet de maintenir un état d'authentification centralisé et facilement accessible à travers votre application.

Pour attacher un token à une requête d'authentification dans une application React, vous pouvez utiliser des mécanismes comme le `Authorization` header dans les requêtes HTTP. Voici comment procéder :

---

### 1. **Stockage et gestion des tokens**

Une fois le token reçu du backend après une connexion réussie, stockez-le de manière sécurisée. Les options courantes incluent :

- **`localStorage`** : Persiste même après le rechargement ou la fermeture du navigateur (moins sécurisé).
- **`sessionStorage`** : Valide uniquement pour l'onglet ouvert.
- **In-memory storage** : Plus sécurisé, mais le token sera perdu au rechargement de la page.

---

### 2. **Attacher le token dans une requête**

Utilisez `fetch` ou une bibliothèque comme `axios` pour inclure le token dans l'en-tête `Authorization`.

#### Exemple avec `fetch` :

```javascript
const handleAutoLogin = async () => {
  const token = localStorage.getItem("authToken"); // Récupérer le token stocké

  if (!token) {
    console.error("Aucun token trouvé");
    return;
  }

  try {
    const response = await fetch("https://api.example.com/auth/auto-login", {
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`, // Ajouter le token dans l'en-tête
        "Content-Type": "application/json",
      },
    });

    if (!response.ok) {
      throw new Error("Échec de la connexion automatique");
    }

    const data = await response.json();
    console.log("Connexion automatique réussie :", data);
    // Mettez à jour l'état de l'utilisateur ou de l'application ici
  } catch (error) {
    console.error("Erreur lors de la connexion automatique :", error);
  }
};
```

---

#### Exemple avec `axios` :

Si vous utilisez `axios`, configurez un `interceptor` pour inclure automatiquement le token dans toutes les requêtes.

```javascript
import axios from "axios";

// Configuration globale du token
const api = axios.create({
  baseURL: "https://api.example.com",
});

// Ajouter le token à toutes les requêtes
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("authToken"); // Récupérer le token stocké
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

const handleAutoLogin = async () => {
  try {
    const response = await api.get("/auth/auto-login"); // Requête avec token inclus
    console.log("Connexion automatique réussie :", response.data);
    // Mettez à jour l'état de l'utilisateur ici
  } catch (error) {
    console.error("Erreur lors de la connexion automatique :", error);
  }
};
```

---

### 3. **Processus complet : Connexion avec gestion des tokens**

Voici un exemple complet pour une gestion basique des tokens :

#### Lors de la connexion :

```javascript
const handleLogin = async (email, password) => {
  try {
    const response = await fetch("https://api.example.com/auth/login", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      throw new Error("Échec de la connexion");
    }

    const { token } = await response.json();
    localStorage.setItem("authToken", token); // Stocker le token
    console.log("Connexion réussie, token sauvegardé");
  } catch (error) {
    console.error("Erreur de connexion :", error);
  }
};
```

#### Lors de l'auto-login ou des requêtes suivantes :

Le token sera automatiquement ajouté en utilisant les méthodes ci-dessus (soit avec `fetch`, soit avec `axios`).

---

### 4. **Considérations de sécurité**

- Ne stockez jamais de tokens sensibles dans des cookies non sécurisés ou du `localStorage` si vous traitez des informations critiques.
- Pour plus de sécurité, utilisez des cookies HTTP-only pour les tokens d'accès ou configurez un système de renouvellement de token (refresh tokens).
- Ajoutez des mécanismes pour vérifier l'expiration du token avant de l'envoyer dans une requête.

## Protection des routes

Pour implémenter la protection des routes dans une application React avec **React Router**, voici une explication étape par étape :

### **1. Créer une Route Protégée (PrivateRoute)**

Une route protégée empêche un utilisateur non authentifié d'accéder à certaines pages sensibles. Si l'utilisateur n'est pas authentifié, il est redirigé vers la page de connexion.

#### **Étape 1 : Créer un composant `PrivateRoute`**

Dans ce composant, nous vérifions l'état d'authentification de l'utilisateur. Si l'utilisateur est authentifié, la route est rendue. Sinon, il est redirigé vers la page de connexion.

```javascript
// PrivateRoute.js
import React from "react";
import { Route, Redirect } from "react-router-dom";
import { useSelector } from "react-redux"; // Si vous utilisez Redux pour gérer l'état d'authentification

const PrivateRoute = ({ component: Component, ...rest }) => {
  // Vérifiez si l'utilisateur est authentifié
  const isAuthenticated = useSelector((state) => state.auth.isAuthenticated);

  return (
    <Route
      {...rest}
      render={(props) =>
        isAuthenticated ? (
          <Component {...props} /> // Si l'utilisateur est authentifié, afficher le composant
        ) : (
          <Redirect to='/login' /> // Sinon, rediriger vers la page de login
        )
      }
    />
  );
};

export default PrivateRoute;
```

#### **Étape 2 : Utiliser `PrivateRoute` dans votre Router**

Maintenant que nous avons un composant `PrivateRoute`, nous pouvons l'utiliser pour protéger des pages spécifiques de votre application.

Voici un exemple de configuration des routes dans votre application avec **React Router** :

```javascript
// App.js
import React from "react";
import { BrowserRouter as Router, Route, Switch } from "react-router-dom";
import { useSelector } from "react-redux";
import HomePage from "./HomePage"; // Exemple de page accessible uniquement par un utilisateur authentifié
import LoginPage from "./LoginPage";
import PrivateRoute from "./PrivateRoute"; // Importation du composant PrivateRoute

const App = () => {
  const isAuthenticated = useSelector((state) => state.auth.isAuthenticated); // Vérifier si l'utilisateur est authentifié

  return (
    <Router>
      <Switch>
        <Route exact path='/login' component={LoginPage} />{" "}
        {/* Page de connexion */}
        {/* Utiliser PrivateRoute pour protéger des routes sensibles */}
        <PrivateRoute exact path='/home' component={HomePage} />
        {/* Vous pouvez ajouter d'autres routes ici */}
      </Switch>
    </Router>
  );
};

export default App;
```

### **2. Gestion de l'état d'authentification avec Redux (optionnel)**

Si vous utilisez **Redux** pour gérer l'état d'authentification, voici un exemple de gestion du store.

#### **Étape 1 : Créer des actions d'authentification**

Voici un exemple de fichier **actions/authActions.js** pour gérer l'authentification.

```javascript
// actions/authActions.js
export const loginSuccess = () => ({
  type: "LOGIN_SUCCESS",
});

export const logout = () => ({
  type: "LOGOUT",
});
```

#### **Étape 2 : Créer un réducteur pour l'authentification**

Voici un réducteur **authReducer.js** qui met à jour l'état d'authentification.

```javascript
// reducers/authReducer.js
const initialState = {
  isAuthenticated: false,
};

export const authReducer = (state = initialState, action) => {
  switch (action.type) {
    case "LOGIN_SUCCESS":
      return { ...state, isAuthenticated: true };
    case "LOGOUT":
      return { ...state, isAuthenticated: false };
    default:
      return state;
  }
};
```

#### **Étape 3 : Ajouter le réducteur dans le store Redux**

Assurez-vous que votre réducteur d'authentification est bien inclus dans votre store.

```javascript
// store.js
import { createStore, combineReducers } from "redux";
import { authReducer } from "./reducers/authReducer";

const rootReducer = combineReducers({
  auth: authReducer,
});

const store = createStore(rootReducer);

export default store;
```

### **3. Résumé des étapes**

1. **Créer un composant `PrivateRoute`** qui vérifie si l'utilisateur est authentifié avant d'afficher une route protégée.
2. **Utiliser `PrivateRoute`** dans votre `Router` pour protéger les pages sensibles.
3. (Optionnel) Utiliser **Redux** ou **useState** pour gérer l'état d'authentification et l'ajouter à votre store.
4. Lorsque l'utilisateur n'est pas authentifié, redirigez-le vers la page de connexion.

---

Avec cette approche, vous pouvez facilement sécuriser les pages qui nécessitent une authentification et garantir que seuls les utilisateurs authentifiés peuvent y accéder.

Si vous souhaitez implémenter une fonctionnalité de **fermeture de session** au lieu de "logout", vous pouvez ajuster le nom des actions et messages pour utiliser des termes plus appropriés en français. Voici un exemple étape par étape pour mettre en place une **fermeture de session automatique**.

### 1. **Renommer "logout" en "fermeture de session"**

#### **Étape 1 : Créer une action de fermeture de session**

Dans votre fichier d'actions, remplacez l'action de déconnexion par une action de **fermeture de session**.

```javascript
// actions/authActions.js
export const fermerSession = () => ({
  type: "FERMETURE_SESSION",
});
```

#### **Étape 2 : Modifier le réducteur pour gérer l'action "FERMETURE_SESSION"**

Dans votre réducteur d'authentification, vous devez gérer l'action de **fermeture de session**.

```javascript
// reducers/authReducer.js
const initialState = {
  isAuthenticated: false,
};

export const authReducer = (state = initialState, action) => {
  switch (action.type) {
    case "LOGIN_SUCCESS":
      return { ...state, isAuthenticated: true };
    case "FERMETURE_SESSION":
      return { ...state, isAuthenticated: false };
    default:
      return state;
  }
};
```

### 2. **Mise en place du Hook pour la fermeture de session automatique**

Vous pouvez utiliser le même principe de timer pour gérer la **fermeture de session automatique** lorsque l'utilisateur reste inactif trop longtemps.

#### **Étape 1 : Créer un hook `useFermetureSession`**

Voici comment vous pouvez créer un hook personnalisé pour gérer la **fermeture de session automatique** en cas d'inactivité.

```javascript
// useFermetureSession.js
import { useEffect } from "react";
import { useDispatch } from "react-redux";
import { fermerSession } from "./actions/authActions"; // L'action fermeture de session

const useFermetureSession = (inactivityTimeout = 600000) => {
  // Le timeout est en millisecondes (ici 10 minutes)
  const dispatch = useDispatch();

  useEffect(() => {
    let timeout;

    const resetTimer = () => {
      clearTimeout(timeout); // Réinitialise le timer
      timeout = setTimeout(() => {
        dispatch(fermerSession()); // Fermeture de session après l'inactivité
        alert(
          "Vous avez été déconnecté automatiquement pour cause d'inactivité."
        ); // Message de fermeture de session
      }, inactivityTimeout);
    };

    // Écouter les événements d'interaction de l'utilisateur
    window.addEventListener("mousemove", resetTimer);
    window.addEventListener("keydown", resetTimer);

    // Initialiser le timer lorsque le composant est monté
    resetTimer();

    // Nettoyer l'événement lors de la destruction du composant
    return () => {
      clearTimeout(timeout);
      window.removeEventListener("mousemove", resetTimer);
      window.removeEventListener("keydown", resetTimer);
    };
  }, [dispatch, inactivityTimeout]);
};

export default useFermetureSession;
```

#### **Étape 2 : Utiliser le Hook `useFermetureSession` dans l'App**

Dans votre composant principal `App.js`, vous allez appeler ce hook pour surveiller l'inactivité de l'utilisateur et effectuer une **fermeture de session automatique**.

```javascript
// App.js
import React from "react";
import { BrowserRouter as Router, Route, Switch } from "react-router-dom";
import { useSelector } from "react-redux";
import HomePage from "./HomePage";
import LoginPage from "./LoginPage";
import PrivateRoute from "./PrivateRoute"; // La route protégée
import useFermetureSession from "./useFermetureSession"; // Importer le hook de fermeture de session

const App = () => {
  const isAuthenticated = useSelector((state) => state.auth.isAuthenticated);

  // Appliquer le hook de fermeture automatique avec un délai d'inactivité de 10 minutes (600000 ms)
  useFermetureSession();

  return (
    <Router>
      <Switch>
        <Route exact path='/login' component={LoginPage} />

        {/* Route protégée */}
        <PrivateRoute exact path='/home' component={HomePage} />
      </Switch>
    </Router>
  );
};

export default App;
```

### 3. **Déconnexion Manuelle (fermeture de session)**

Voici comment vous pouvez implémenter une fonction pour fermer manuellement la session dans votre application.

#### **Étape 1 : Ajouter un bouton pour la fermeture de session**

Dans votre composant où vous souhaitez ajouter la possibilité de fermer la session manuellement, vous pouvez afficher un bouton "Fermer la session".

```javascript
// Exemple de composant où l'utilisateur peut fermer la session manuellement
import React from "react";
import { useDispatch } from "react-redux";
import { fermerSession } from "./actions/authActions"; // Importer l'action de fermeture de session

const ProfilePage = () => {
  const dispatch = useDispatch();

  const handleLogout = () => {
    dispatch(fermerSession()); // Fermeture de session manuelle
    alert("Vous avez fermé la session !");
  };

  return (
    <div>
      <h2>Bienvenue sur votre profil</h2>
      <button onClick={handleLogout}>Fermer la session</button>
    </div>
  );
};

export default ProfilePage;
```

### Résumé

1. **Création d'une action `FERMETURE_SESSION`** qui réinitialise l'état d'authentification.
2. **Création d'un hook `useFermetureSession`** qui écoute les événements d'inactivité et ferme la session après un certain délai.
3. **Utilisation de la fermeture de session manuelle** avec un bouton de "Fermer la session".

Cela vous permettra de gérer à la fois les fermetures automatiques et manuelles de session dans votre application React.

Pour gérer l'expiration du token dans une application React, voici une approche pas à pas pour implémenter cette fonctionnalité. Cela garantit que l'utilisateur sera déconnecté lorsque son token d'authentification expire.

### 1. **Vérification de l'expiration du token**

Un **token d'authentification** (comme un JWT) a généralement une date d'expiration (expiration time) qui est incluse dans le payload du token lui-même. Vous pouvez utiliser cette information pour déterminer si le token est toujours valide ou si l'utilisateur doit être déconnecté.

### 2. **Décoder le Token pour Vérifier l'Expiration**

Pour vérifier l'expiration, vous pouvez utiliser une bibliothèque comme `jwt-decode` pour extraire la date d'expiration du token. Ensuite, vous pouvez vérifier cette date contre l'heure actuelle.

#### **Étape 1 : Installer la bibliothèque `jwt-decode`**

```bash
npm install jwt-decode
```

#### **Étape 2 : Créer une fonction pour vérifier l'expiration**

```javascript
// utils/tokenUtils.js
import jwt_decode from "jwt-decode";

export const isTokenExpired = (token) => {
  if (!token) return true;

  const decoded = jwt_decode(token);
  const currentTime = Date.now() / 1000; // Convertir en secondes
  return decoded.exp < currentTime;
};
```

### 3. **Gérer l'Expiration du Token dans le Composant Principal**

Dans votre composant principal (par exemple `App.js`), vous devez vérifier l'expiration du token à chaque fois que l'application est chargée. Si le token est expiré, vous déconnectez l'utilisateur automatiquement.

#### **Étape 1 : Vérification de l'expiration dans le `useEffect`**

```javascript
// App.js
import React, { useEffect } from "react";
import { useDispatch } from "react-redux";
import { useHistory } from "react-router-dom";
import { fermerSession } from "./actions/authActions"; // L'action de fermeture de session
import { isTokenExpired } from "./utils/tokenUtils"; // Utiliser la fonction pour vérifier l'expiration du token

const App = () => {
  const dispatch = useDispatch();
  const history = useHistory();

  useEffect(() => {
    const token = localStorage.getItem("authToken"); // Ou sessionStorage si vous préférez
    if (token && isTokenExpired(token)) {
      dispatch(fermerSession()); // Déconnexion automatique si le token est expiré
      history.push("/login"); // Rediriger l'utilisateur vers la page de connexion
      alert("Votre session a expiré. Veuillez vous reconnecter.");
    }
  }, [dispatch, history]);

  return <div>{/* Votre application ici */}</div>;
};

export default App;
```

### 4. **Déconnexion Manuelle si le Token Est Expiré**

Si l'utilisateur tente d'accéder à une page protégée avec un token expiré, il devrait être redirigé vers la page de connexion et recevoir une notification. Vous pouvez utiliser un composant `PrivateRoute` pour gérer cette logique.

#### **Étape 1 : Créer une Route Protégée (PrivateRoute)**

```javascript
// PrivateRoute.js
import React from "react";
import { Route, Redirect } from "react-router-dom";
import { useSelector } from "react-redux";
import { isTokenExpired } from "./utils/tokenUtils"; // Utiliser la fonction pour vérifier l'expiration du token

const PrivateRoute = ({ component: Component, ...rest }) => {
  const token = localStorage.getItem("authToken"); // Ou sessionStorage si vous préférez
  const isAuthenticated = useSelector((state) => state.auth.isAuthenticated);

  if (token && isTokenExpired(token)) {
    // Déconnecter automatiquement si le token est expiré
    return <Redirect to='/login' />;
  }

  return (
    <Route
      {...rest}
      render={(props) =>
        isAuthenticated ? <Component {...props} /> : <Redirect to='/login' />
      }
    />
  );
};

export default PrivateRoute;
```

### 5. **Gestion du Refresh Token (Optionnel)**

Si vous utilisez un système de **refresh token** pour maintenir l'utilisateur connecté après l'expiration de son token d'accès, vous pouvez également l'implémenter dans votre logique de gestion de l'expiration. Voici un aperçu :

#### **Étape 1 : Créer un Endpoint pour Rafraîchir le Token**

Dans votre backend, vous pouvez créer un endpoint pour générer un nouveau token d'accès à partir du refresh token lorsque celui-ci est expiré.

```javascript
// Exemple d'API backend pour rafraîchir le token
app.post("/api/refresh-token", (req, res) => {
  const { refreshToken } = req.body;
  if (!refreshToken) return res.status(400).send("Refresh token manquant");

  // Vérifiez et générez un nouveau token d'accès
  const newAccessToken = generateAccessToken(refreshToken);
  res.json({ accessToken: newAccessToken });
});
```

#### **Étape 2 : Rafraîchir le Token dans l'App**

Dans votre application, vous pouvez vérifier l'expiration du token et appeler l'API de rafraîchissement pour obtenir un nouveau token d'accès.

```javascript
// Exemple de logique de rafraîchissement de token dans le frontend
import { useDispatch } from "react-redux";
import { fermerSession } from "./actions/authActions";
import axios from "axios";

const refreshToken = async (refreshToken) => {
  try {
    const response = await axios.post("/api/refresh-token", { refreshToken });
    return response.data.accessToken;
  } catch (error) {
    console.error("Erreur lors du rafraîchissement du token", error);
    return null;
  }
};

const handleTokenExpiration = async () => {
  const token = localStorage.getItem("authToken");
  const refreshToken = localStorage.getItem("refreshToken"); // Le refresh token stocké dans le localStorage

  if (token && isTokenExpired(token) && refreshToken) {
    const newAccessToken = await refreshToken(refreshToken);
    if (newAccessToken) {
      localStorage.setItem("authToken", newAccessToken); // Mettre à jour le token
    } else {
      dispatch(fermerSession()); // Déconnexion si le refresh échoue
    }
  }
};
```

### Résumé

1. **Vérification de l'expiration du token** : Utilisez une fonction qui décode le JWT et compare l'expiration avec l'heure actuelle.
2. **Déconnexion automatique** : Si le token est expiré, l'utilisateur est automatiquement déconnecté et redirigé vers la page de connexion.
3. **Refresh Token** : Si vous utilisez un refresh token, implémentez une logique pour récupérer un nouveau token lorsque celui-ci expire.

Cela garantit une gestion fluide de l'expiration du token tout en protégeant votre application.
